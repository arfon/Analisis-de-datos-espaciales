<!DOCTYPE html>
<html lang="es">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>3 Análisis espacial I: autocorrelación | Análisis de datos espaciales con R: manejo, visualización y modelos econométricos</title>
<meta name="author" content="Jaime Alberto Prudencio Vázquez">
<meta name="generator" content="bookdown 0.24.1 with bs4_book()">
<meta property="og:title" content="3 Análisis espacial I: autocorrelación | Análisis de datos espaciales con R: manejo, visualización y modelos econométricos">
<meta property="og:type" content="book">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="3 Análisis espacial I: autocorrelación | Análisis de datos espaciales con R: manejo, visualización y modelos econométricos">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.0.4.1/leaflet.js"></script><script src="libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js"></script><script src="libs/leaflet-providers-plugin-2.0.4.1/leaflet-providers-plugin.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><meta name="description" content="3.1 Autocorrelación y dependencia espacial  La identificación de autocorrelación espacial es importante como parte del proceso de análisis del fenómeno socioterritoriales al menos por dos...">
<meta property="og:description" content="3.1 Autocorrelación y dependencia espacial  La identificación de autocorrelación espacial es importante como parte del proceso de análisis del fenómeno socioterritoriales al menos por dos...">
<meta name="twitter:description" content="3.1 Autocorrelación y dependencia espacial  La identificación de autocorrelación espacial es importante como parte del proceso de análisis del fenómeno socioterritoriales al menos por dos...">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">Análisis de datos espaciales con R: manejo, visualización y modelos econométricos</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Prólogo</a></li>
<li><a class="" href="r-una-introducci%C3%B3n-desde-la-exploraci%C3%B3n-de-informaci%C3%B3n.html"><span class="header-section-number">1</span> R: Una introducción desde la exploración de información</a></li>
<li><a class="" href="mapas-coropl%C3%A9ticos-en-r.html"><span class="header-section-number">2</span> Mapas coropléticos en R</a></li>
<li><a class="active" href="an%C3%A1lisis-espacial-i-autocorrelaci%C3%B3n.html"><span class="header-section-number">3</span> Análisis espacial I: autocorrelación</a></li>
<li><a class="" href="modelos-de-regresi%C3%B3n-lineal.html"><span class="header-section-number">4</span> Modelos de regresión lineal</a></li>
<li><a class="" href="an%C3%A1lisis-espacial-ii-modelos-econom%C3%A9tricos-espaciales.html"><span class="header-section-number">5</span> Análisis espacial II: modelos econométricos espaciales</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="análisis-espacial-i-autocorrelación" class="section level1" number="3">
<h1>
<span class="header-section-number">3</span> Análisis espacial I: autocorrelación<a class="anchor" aria-label="anchor" href="#an%C3%A1lisis-espacial-i-autocorrelaci%C3%B3n"><i class="fas fa-link"></i></a>
</h1>
<div id="autocorrelación-y-dependencia-espacial" class="section level2" number="3.1">
<h2>
<span class="header-section-number">3.1</span> Autocorrelación y dependencia espacial<a class="anchor" aria-label="anchor" href="#autocorrelaci%C3%B3n-y-dependencia-espacial"><i class="fas fa-link"></i></a>
</h2>
<div style="text-align: justify">
<p>La identificación de autocorrelación espacial es importante como parte del proceso de análisis del fenómeno socioterritoriales al menos por dos cuestiones, una de carácter técnico y otra de carácter sustantivo. Respecto a los elementos técnicos es posible sostener que, si existe autocorrelación espacial en nuestros datos, lo más probable es que los métodos de estimación de los parámetros del modelo propuesto a través de mínimos cuadrados ordinarios dejen de ser válidos, en la medida en que no se cumplen los supuestos que requiere dicho procedimiento, específicamente, que los errores o perturbaciones del modelo no estén correlacionados. Por otro lado, cuando nos referimos a elementos sustantivos estamos queriendo expresar que nuestro fenómeno de interés, aquél que buscamos captar a través del modelo propuesto, en realidad estaría dejando de lado un comportamiento sistemático de asociación a nivel territorial.</p>
<p>Sobre este segundo punto detengámonos un momento. ¿Qué puede estar ocurriendo que hace que los fenómenos se no se distribuyan aleatoriamente en el espacio? Por ejemplo, ¿por qué se concentra la actividad económica en determinadas ciudades o por qué algunos servicios sólo se brindan en una zona de la ciudad? Esto respecto a fenómenos económicos, pero ¿qué hay con el hecho de que una enfermedad se concentra notoriamente en algunas áreas de la ciudad y no en otras? Dicho en otras palabras, ¿qué hay detrás de la formación de un patrón en la forma en que se distribuye un fenómeno en el espacio y cómo puede ser explicado? A eso nos referimos cuando decimos que hay elementos sustantivos para el análisis al hallar evidencia de autocorrelación espacial.</p>
<p>Un clásico ejemplo de lo provechoso que es el análisis espacial que indaga sobre patrones de relación espacial sustantivos es el caso de estudio de <a href="https://es.wikipedia.org/wiki/John_Snow">John Snow</a> que en 1854 investigó las muertes por cólera en el barrio de Soho, en Londres. En esos años no se sabía con exactitud el mecanismo de transmisión del cólera, se creía que éste se adquiría por la ingesta de agua o alimentos contaminados (tal y cómo después se verificó gracias a los trabajos de Snow) o por respirar aire contaminado. En el material preparado por el <em>Center for Spatial Data Science</em> de la Universidad de Chicago, podrás encontrar el modo en que el análisis espacial puede ayudar a plantear y resolver las preguntas adecuadas: <a href="https://uploads.knightlab.com/storymapjs/a0d512bc2bc17977f1029fedead0329a/trying-out/index.html">Asking the right questions in spatial anaysis: the case of John Snow</a>.</p>
<p>Una definición sintética de autocorrelación espacial es la que nos brinda Chasco (2003) como “la relación funcional existente entre los valores que adopta un indicador en una zona del espacio y en zonas vecinas” <span class="citation">(<a href="references.html#ref-Chasco2003" role="doc-biblioref">Chasco 2003, 49</a>)</span>.</p>
<p>La definición se integra por tres elementos clave: i) valor de un indicador, ii) relación funcional y iii) zonas vecinas. Para dar sentido a nuestra definición pensemos en una afirmación como “los casos positivos de COVID19 en la alcaldía Azcapotzalco están asociados en forma directa con los casos positivos de COVID19 en las alcaldías y municipios vecinos que integran la Zona Metropolitana del Valle de México”. Tendríamos entonces que:</p>
<ol style="list-style-type: lower-roman">
<li>Indicador: casos positivos por COVID19.<br>
</li>
<li>Relación funcional: asociación positiva o directa.<br>
</li>
<li>Zonas vecinas: alcaldías y municipios vecinos de Azcapotzalco.</li>
</ol>
<p>El primer elemento no presenta demasiadas dificultades ya que en la base de datos que hemos estado utilizando tenemos los casos positivos por COVID19 por cada 1 mil habitantes; en tanto, el segundo elemento de nuestra afirmación es una mera suposición, es decir, que hay una relación positiva; por su parte, el tercer elemento “alcaldías y municipios vecinos” implica un problema: ¿de qué modo es posible establecer que alcaldías son o no vecinas de Azcapotzalco?</p>
<p>Hay múltiples maneras que definir si un objeto espacial tiene o no vecinos, por ejemplo, podríamos decir que aquellas alcaldías que compartan límites administrativos con la demarcación territorial de nuestro interés serán sus vecinos (vecindad por adyacencia) o también sería posible establecer que las alcaldías vecinas serán aquellas que estén a menos de 10 km de distancia del centro económico de la alcaldía (vecindad por umbral de distancia).</p>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: lower-roman">
<li><p>¿Se te ocurre algún otro criterio para establecer vecindad?</p></li>
<li><p>¿Cómo llamarías a un criterio de vecindad donde elijas a los 3 vecinos más cercanos?</p></li>
<li><p>¿A partir de qué punto será más conveniente medir la distancia, desde el centro económico de la alcaldía o municipio (por ejemplo su zona industrial o comercial) o desde la sede de la administración local?</p></li>
<li><p>¿La distancia más indicada usada como criterio de vecindad será una distancia lineal o una distancia por carretera?</p></li>
</ol>
<hr>
<p>Los interesados en el análisis espacial han propuesto un ingenioso instrumento matemático para captar y sintetizar cómo un objeto se relaciona con otros en el espacio, es decir, para captar la <em>estructura espacial</em> del área de interés. Piensa en un vecindario o área de estudio compuesto sólo por seis elementos, tal como se ilustra en la figura 3.1:</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-110"></span>
<img src="recursos%203/Vecindario%20regular.jpg" alt="Vecindario regular" width="100%"><p class="caption">
Figura 3.1: Vecindario regular
</p>
</div>
<p>A partir de la disposición de este hipotético vecindario nos interesa construir un instrumento para captar su estructura espacial a través de un criterio de adyacencia o contigüidad. A decir de Anselin (2020) “contigüidad significa que dos unidades espaciales comparten un borde común de longitud distinta de cero. Desde el punto de vista operativo, podemos distinguir aún más entre un criterio de contigüidad de tipo torre y de tipo reina, en analogía con los movimientos permitidos para las piezas así nombradas en un tablero de ajedrez. El criterio de la torre define a los vecinos por la existencia de un borde común entre dos unidades espaciales. El criterio de la reina es algo más amplio y define a los vecinos como unidades espaciales que comparten un borde o un vértice comunes” <span class="citation"><a href="references.html#ref-Anselin2020" role="doc-biblioref">Anselin</a> (<a href="references.html#ref-Anselin2020" role="doc-biblioref">2020</a>)</span>.</p>
<p>Ahora bien, ¿cómo podemos plasmar las relaciones de contigüidad de forma sintética. Pensemos en un cuadro que tiene tantas filas y columnas como objetos espaciales tiene nuestro vecindario, semejante al que aparece en la figura 3.2.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-111"></span>
<img src="recursos%203/Matriz%20ejemplo-vac%C3%ADa.jpg" alt="Matriz ejemplo vacía" width="100%"><p class="caption">
Figura 3.2: Matriz ejemplo vacía
</p>
</div>
<p>Coloquemos el número uno si el elemento 1 y el 2 comparten un lado, en caso contrario, coloquemos un cero. Hagamos esto para cada celda de este cuadro hasta que lo llenemos y obtengamos algo parecido a lo que aparece en la figura 3.3.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-112"></span>
<img src="recursos%203/Matriz%20ejemplo-llena.jpg" alt="Matriz ejemplo llena" width="100%"><p class="caption">
Figura 3.3: Matriz ejemplo llena
</p>
</div>
<p>El cuadro que acabamos de llenar es conocido como <em>matriz de pesos espaciales</em><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;“La estructura espacial suele expresarse formalmente a través de una matriz de interacciones espaciales, también llamada “matriz de pesos, ponderaciones, distancias o contactos espaciales” &lt;span class="citation"&gt;(&lt;a href="references.html#ref-Chasco2003" role="doc-biblioref"&gt;Chasco 2003, 55&lt;/a&gt;)&lt;/span&gt;&lt;/p&gt;'><sup>3</sup></a>. Habrá, por tanto, diversos tipos de matrices en función del criterio de vecindad elegido y del propio fenómeno analizado. No obstante, la más usual es una matriz de contigüidad binaria de <span class="math inline">\(n\)</span> x <span class="math inline">\(n\)</span>, donde <span class="math inline">\(n\)</span> es el número de objetos espaciales.</p>
<p>Este tipo de matriz, denotado por la letra mayúscula <span class="math inline">\(W\)</span>, contiene como elementos <span class="math inline">\(w_{ij}\)</span> : el número 1 cuando el elemento <span class="math inline">\(j\)</span> y el elemento <span class="math inline">\(i\)</span> sean vecinos, o bien, 0 (cero) en cualquier otro caso. Este instrumento es uno de los más importantes en econometría espacial ya que permite construir los estadísticos de autocorrelación espacial y es la manera en que podemos incorporar al espacio como variable a partir de lo que denominamos “rezago espacial”. De la imagen anterior es posible apuntar algunas de las características de esta matriz:</p>
<ul>
<li>Es una matriz que en la diagonal principal contiene sólo ceros, es decir, se asume que por definición no hay interacción espacial dentro de un mismo elemento (lo que no necesariamente es cierto y que dependerá de la dimensión espacial de análisis).<br>
</li>
<li>Es una matriz simétrica, es decir, se asume que hay interacción de “ida y vuelta”, por lo que con un instrumento de estas características no es posible asumir efectos de interacción en un solo sentido.</li>
</ul>
<p>Aquí acabamos de ilustrar la lógica con la que puede ser construida una matriz de pesos espaciales a partir de una retícula regular con apenas seis elementos. Veamos ahora cómo obtener matrices de pesos espaciales sirviéndonos de R, ya que desarrollar los pasos anteriores para un vecindario compuesto por 76 elementos como los que integran el Valle de México es tarea para una máquina, no para nosotros.</p>
</div>
<div id="matrices-de-pesos-espaciales-en-r" class="section level2" number="3.2">
<h2>
<span class="header-section-number">3.2</span> Matrices de pesos espaciales en R<a class="anchor" aria-label="anchor" href="#matrices-de-pesos-espaciales-en-r"><i class="fas fa-link"></i></a>
</h2>
<div id="los-paquetes-1" class="section level3" number="3.2.1">
<h3>
<span class="header-section-number">3.2.1</span> Los paquetes<a class="anchor" aria-label="anchor" href="#los-paquetes-1"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>En R hay muchas rutas para desarrollar la misma tarea. Lo que presentamos en este capítulo es una de múltiples maneras que pueden encontrarse para la construcción de matrices de pesos espaciales en R. En el apéndice, encontrarás otra alternativa, un tanto más elaborada. La manera en que desarrollamos en esta sección la tarea de construir las matrices de pesos espaciales se sirve de los siguientes paquetes:</p>
<ul>
<li>
<code>rgdal</code>: según se lee en la documentación, “proporciona enlaces a la biblioteca de abstracción de datos ‘geoespaciales’”</li>
<li>
<code>spdep</code>: contiene todo un arsenal de funciones para el análisis espacial, que permiten crear matrices de pesos espaciales, así como evaluar autocorrelación espacial.</li>
</ul>
<p>Como es usual, se deben descargar e instalar los paquetes:</p>
<div class="sourceCode" id="cb173"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html">install.packages</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"rgdal"</span>,<span class="st">"spdep"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>Para cargarlos:</p>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/r-spatial/spdep/">spdep</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://rgdal.r-forge.r-project.org">rgdal</a></span><span class="op">)</span></code></pre></div>
</div>
<div id="matrices-de-contigüidad-el-argumento-queen-de-la-función-poly2nb" class="section level3" number="3.2.2">
<h3>
<span class="header-section-number">3.2.2</span> Matrices de contigüidad: el argumento <code>queen</code> de la función <code>poly2nb()</code><a class="anchor" aria-label="anchor" href="#matrices-de-contig%C3%BCidad-el-argumento-queen-de-la-funci%C3%B3n-poly2nb"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Primero, carguemos la base de datos espacial. En este caso, recurrimos a la función <code>readOGR</code> que forma parte del paquete <code>rgdal</code> para leer los archivos de tipo SHP.</p>
<div class="sourceCode" id="cb175"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">covid_zmvm</span> <span class="op">&lt;-</span><span class="fu">rgdal</span><span class="fu">::</span><span class="fu"><a href="http://rgdal.r-forge.r-project.org/reference/readOGR.html">readOGR</a></span><span class="op">(</span><span class="st">"base de datos\\covid_zmvm shp\\covid_zmvm.shp"</span><span class="op">)</span></code></pre></div>
<pre><code>## Warning in OGRSpatialRef(dsn, layer, morphFromESRI = morphFromESRI, dumpSRS =
## dumpSRS, : Discarded datum D_unknown in Proj4 definition: +proj=lcc +lat_0=12
## +lon_0=-102 +lat_1=17.5 +lat_2=29.5 +x_0=2500000 +y_0=0 +ellps=GRS80 +units=m
## +no_defs</code></pre>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: "C:\Users\Jarvis\Desktop\Analisis espacial con R studio\base de datos\covid_zmvm shp\covid_zmvm.shp", layer: "covid_zmvm"
## with 76 features
## It has 55 fields</code></pre>
<p>Observa el objeto en tu ambiente de trabajo. Notaras que es un objeto de tipo <em>Spatial polygons data frame</em> y al hacer clic en la imagen de la lente de aumento no se desplegará la base de datos como es usual, sino que estará almacenada y agrupada de otra manera:</p>
<ul>
<li>
<em>data</em>: aquí están almacenados los datos de nuestro archivo .dbf.<br>
</li>
<li>
<em>polygons</em>: la geometría del área estudiada se almacena aquí y se identifica a cada polígono (municipio o alcaldía) con un número del 1 al 76.<br>
</li>
<li>proj4string: recoge la información relativa al tipo de proyección cartográfica usada en nuestra base.</li>
</ul>
<p>Cuando en la computadora queremos definir una estructura espacial lo hacemos con un tipo de objeto que denominamos lista y no con matrices, es decir, el objeto con el que interactuaremos en R no será uno de tipo <code>matrix</code>, sino una especie de lista. El hecho de que se usen listas y no matrices para el proceso de cómputo es porque resulta más conveniente en términos de la cantidad ocupada de recursos del sistema puesto que las matrices, como las comentadas en la sección anterior, son <em>matrices dispersas</em>, es decir, contienen muchos elementos que son cero.</p>
<p>La función <code><a href="https://r-spatial.github.io/spdep/reference/poly2nb.html">poly2nb()</a></code> del paquete <code>spdep</code> nos permite calcular dos tipos de vecindad por adyacencia a través del argumento lógico <code>queen</code>. En la documentación de la función podemos leer que: “si es VERDADERO, <code>TRUE</code>, un solo punto límite compartido cumple la condición de contigüidad; si es FALSO, <code>FALSE</code>, se requiere más de un punto compartido; ten en cuenta que más de un punto límite compartido no significa necesariamente una línea límite compartida”.</p>
<p>Lo dicho en el párrafo anterior es relevante en el sentido de que los estos criterios, los usados por R en la construcción de matrices, no son exactamente los mismos que definimos antes (contigüidad reina y torre). Aquí la diferencia entre asignar como verdadero o falso el argumento <code>queen=</code>, puede ser interpretado como un criterio menos estricto o más estricto, respectivamente.</p>
<p>Vamos a construir un objeto que llamaremos <code>mTRUE</code>, dicho objeto contendrá los elementos que definen la vecindad:</p>
<div class="sourceCode" id="cb178"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mTRUE</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/poly2nb.html">poly2nb</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">)</span></code></pre></div>
<p>El segmento de código anterior genera un objeto de tipo <code>nb</code>. Verifica sus características con <code><a href="https://rdrr.io/r/base/class.html">class()</a></code> y <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code> . Además, nota que en la sección de ambiente de trabajo (cuadrante superior derecho, en la pestaña ambiente) aparece el objeto creado. Da clic en la imagen de la lupa para visualizarlo e intenta interpretar el resultado de la ventana.</p>
<p>Ahora, llama a el objeto y presta atención sobre los resultados que ofrece:</p>
<div class="sourceCode" id="cb179"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mTRUE</span></code></pre></div>
<pre><code>## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 384 
## Percentage nonzero weights: 6.648199 
## Average number of links: 5.052632</code></pre>
<p>En la consola aparecen los siguientes elementos:</p>
<p><em>Objeto de lista de vecinos:</em></p>
<ul>
<li>Número de regiones: 76. Corresponde al número de alcaldías y municipios que componen la Zona Metropolitana del Valle de México.<br>
</li>
<li>Número de enlaces distintos de cero: 380. Es el número de elementos de una matriz de 76x76 diferentes de cero.<br>
</li>
<li>Porcentaje de pesos distintos de cero: 6.57. Resultado de dividir 380 entre (76x76).<br>
</li>
<li>Número promedio de vecinos o vínculos: 5. Número de vecinos que en promedio tiene cada municipio o alcaldía.</li>
</ul>
<p>Ahora bien, para construir una lista de vecindad con base en un criterio más estricto, es decir, <code>queen = FALSE</code>, procedemos como:</p>
<div class="sourceCode" id="cb181"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mFALSE</span><span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/poly2nb.html">poly2nb</a></span><span class="op">(</span><span class="va">covid_zmvm</span>, queen <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p>Ahora, llama dicho objeto y contrasta con los resultados anteriores.</p>
<div class="sourceCode" id="cb182"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mFALSE</span></code></pre></div>
<pre><code>## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 372 
## Percentage nonzero weights: 6.440443 
## Average number of links: 4.894737</code></pre>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: lower-roman">
<li><p>¿Qué objeto, <code>mTRUE</code> o <code>mFALSE</code>, tiene el mayor número de vínculos diferentes de cero?</p></li>
<li><p>¿Por qué crees que esto es así?</p></li>
</ol>
<hr>
<p>Es posible observar que, con base en este segundo criterio de vecindad, se identificaron un menor número de vecinos (número de vínculos diferente de cero).</p>
<p>Estas listas, que contienen nuestras estructuras espaciales en los objeto de tipo <code>nb</code> llamados <code>mTRUE</code> y <code>mFALSE</code>, pueden representarse visualmente a través de un <em>gráfico de conectividad</em> que representa la estructura espacial definida por cada criterio a través de líneas que unen a los municipios considerados vecinos.</p>
<p>Para visualizar el mapa de conectividad recurrimos a la función <code><a href="https://r-spatial.github.io/sf/reference/plot.html">plot()</a></code> y superpondremos dos gráficas: una sólo con los bordes o límites a nivel municipal y otra con los centroides y la estructura espacial. Aquí se muestra el mapa de conectividad resultado de la matriz <code>mTRUE</code></p>
<div class="sourceCode" id="cb184"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">covid_zmvm</span>, border <span class="op">=</span> <span class="st">'lightgrey'</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mTRUE</span>, <span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html">coordinates</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">)</span>, add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">'lightblue'</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-120-1.png" width="672"></div>
<p>Para comparar ambas formas podemos superponer las dos gráficas y asignar colores diferentes:</p>
<div class="sourceCode" id="cb185"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">covid_zmvm</span>, border <span class="op">=</span> <span class="st">'lightgrey'</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mTRUE</span>, <span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html">coordinates</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">)</span>, add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">'blue'</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mFALSE</span>, <span class="fu"><a href="https://rdrr.io/pkg/sp/man/coordinates.html">coordinates</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">)</span>, add<span class="op">=</span><span class="cn">TRUE</span>, col<span class="op">=</span><span class="st">'lightgreen'</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-121-1.png" width="672"></div>
<p>Como puedes observar, son estructuras muy parecidas, aunque es posible notar sus diferencias. Es ampliamente recomendable que revises el apéndice de este capítulo pues en él se trata un enfoque diferente para la construcción de matrices de pesos espaciales que, si bien es más complejo, te puede servir para avanzar en tu conocimiento sobre R.</p>
</div>
</div>
<div id="estadísticos-de-correlación-espacial" class="section level2" number="3.3">
<h2>
<span class="header-section-number">3.3</span> Estadísticos de correlación espacial<a class="anchor" aria-label="anchor" href="#estad%C3%ADsticos-de-correlaci%C3%B3n-espacial"><i class="fas fa-link"></i></a>
</h2>
<div id="la-matriz-de-pesos-espaciales-estandarizada" class="section level3" number="3.3.1">
<h3>
<span class="header-section-number">3.3.1</span> La matriz de pesos espaciales estandarizada<a class="anchor" aria-label="anchor" href="#la-matriz-de-pesos-espaciales-estandarizada"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Antes dijimos que cada uno de los elementos <span class="math inline">\(w_{ij}\)</span> de la matriz <span class="math inline">\(W\)</span> pueden tomar como valores ceros o unos. La matriz <span class="math inline">\(W\)</span> puede escribirse como:</p>
<p><span class="math display">\[
W=
\begin{pmatrix}
w_{11} &amp; w_{12} &amp; \cdots  &amp; w_{1n}\\
w_{21} &amp; w_{22} &amp; \cdots  &amp; w_{2n}\\
\vdots &amp; \vdots &amp; \ddots  &amp; \vdots \\
w_{n1} &amp; w_{n2} &amp; \dots  &amp; w_{nn}\\
\end{pmatrix}
\]</span></p>
<p>No obstante, es posible expresar dicha matriz <span class="math inline">\(W\)</span> de una forma diferente, normalizandola por filas. Normalizar una matriz de pesos espaciales por filas implica dividir cada elemento <span class="math inline">\(w_{ij}\)</span> de una fila entre la suma de elementos diferentes a cero de dicha fila, es decir:</p>
<p><span class="math display">\[w_{ij(s)}=\frac {w_{ij}} {\sum{w_{ij}}}\]</span>
La matriz de pesos espaciales estandarizada es la que usaremos en lo sucesivo para construir lo que denominaremos rezago espacial y para la construcción de estadísticos de correlación espacial, un poco más adelante. El proceso de estandarización de las matrices que recién creamos, los objetos <code>mTRUE</code> y <code>mFALSE</code>, corre a cuenta de la función <code><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw()</a></code> del paquete <code>spdep</code>:</p>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mTRUE.pesos</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw</a></span><span class="op">(</span><span class="va">mTRUE</span><span class="op">)</span>
<span class="va">mTRUE.pesos</span></code></pre></div>
<pre><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 384 
## Percentage nonzero weights: 6.648199 
## Average number of links: 5.052632 
## 
## Weights style: W 
## Weights constants summary:
##    n   nn S0       S1       S2
## W 76 5776 76 35.56142 319.6623</code></pre>
<div class="sourceCode" id="cb188"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mFALSE.pesos</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw</a></span><span class="op">(</span><span class="va">mFALSE</span><span class="op">)</span>
<span class="va">mFALSE.pesos</span></code></pre></div>
<pre><code>## Characteristics of weights list object:
## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 372 
## Percentage nonzero weights: 6.440443 
## Average number of links: 4.894737 
## 
## Weights style: W 
## Weights constants summary:
##    n   nn S0       S1       S2
## W 76 5776 76 36.56499 319.6716</code></pre>
<p>Notaras cómo en el ambiente de trabajo se ha creado un objeto nuevo de tipo <code>listw</code>. Ábrelo y observa su contenido.</p>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: lower-roman">
<li><p>¿Logras comprender por qué se le denomina matriz (lista) estandarizada?</p></li>
<li><p>¿Logras identificar cómo la suma de cada renglón de la lista es igual a uno? ¿Cómo se relaciona la forma en que aparecen enlistados los elementos con el número de vecinos que tiene cada objeto espacial?</p></li>
</ol>
<hr>
</div>
<div id="el-rezago-o-retardo-espacial" class="section level3" number="3.3.2">
<h3>
<span class="header-section-number">3.3.2</span> El rezago o retardo espacial<a class="anchor" aria-label="anchor" href="#el-rezago-o-retardo-espacial"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Regresemos a nuestra definición sobre la autocorrelación espacial: relación funcional existente entre los valores que adopta un indicador en una zona del espacio y en zonas vecinas. Ya hemos visto cómo podemos operacionalizar el concepto de vecindad, por lo que podemos ahora concentrémonos en los otros elementos. Comencemos con aquel que define el valor de una variable en las zonas vecinas, a lo que llamaremos <em>variable espacialmente rezagada</em>. Una variable espacialmente rezagada no es otra cosa que un promedio ponderado del valor de una variable en un sitio y sus locaciones vecinas <span class="citation">(<a href="references.html#ref-Chasco2003" role="doc-biblioref">Chasco 2003, 61</a>; <a href="references.html#ref-Anselin2020" role="doc-biblioref">Anselin 2020</a>)</span>. Siguiendo a <span class="citation">(<a href="references.html#ref-Anselin2020" role="doc-biblioref">Anselin 2020</a>)</span>, "el rezago espacial de <span class="math inline">\(y\)</span> del objeto espacial <span class="math inline">\(i\)</span> es expresado como <span class="math inline">\(Wy_{i}\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
Wy_i &amp;=  w_{i1}y_1+w_{i2}y_2+...+w_{in}y_n \\
Wy_i &amp;=  \sum_{j=1}^nw_{ij}y_j \\
\end{aligned}
\]</span></p>
<p>Recuerda que <span class="math inline">\(w_{ij}\)</span> no es otra cosa que cada uno de los elementos de la matriz de pesos estandarizada por fila y que define la estructura de asociación en el espacio.</p>
<p>Construiremos un rezago espacial de la variable <code>pos_hab</code> con ayuda de la función <code><a href="https://r-spatial.github.io/spdep/reference/lag.listw.html">lag.listw()</a></code> del paquete <code>spdep</code>. Indicamos dos argumentos en la función: la estructura espacial dada por la matriz estandarizada, <code>mTRUE.pesos</code>, y la variable de la que deseamos el rezago espacial, <code>pos_hab</code>, esto es guardado en un nuevo objeto, <code>lag_poshab</code>, tal y como se muestra en el siguiente segmento de código:</p>
<div class="sourceCode" id="cb190"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">lag_poshab</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-spatial.github.io/spdep/reference/lag.listw.html">lag.listw</a></span><span class="op">(</span><span class="va">mTRUE.pesos</span>, <span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">)</span></code></pre></div>
<p>Para lograr apreciar mejor nuestro rezago espacial, construiremos una tabla de dos columnas que almacenaremos en el objeto <code>df</code>, la primera contendrá la variable original y la segunda el rezago espacial, luego pediremos que nos muestre los primeros registros de la tabla con la función <code><a href="https://rdrr.io/r/utils/head.html">head()</a></code> en un formato estilizado a través de la función <code><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable()</a></code> del paquete <code>knitr</code>:</p>
<div class="sourceCode" id="cb191"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Crea un nuevo arreglo de datos donde se almacena la variable original y el rezago espacial</span>
<span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>pos_hab <span class="op">=</span> <span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span>, <span class="va">lag_poshab</span><span class="op">)</span>

<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://yihui.org/knitr/">knitr</a></span><span class="op">)</span>

<span class="co">#Coloca los primeros valores de ambas variables en una tabla, requiere instalación y carga del paquete  knitr</span>
<span class="fu"><a href="https://rdrr.io/pkg/knitr/man/kable.html">kable</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">df</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="inline-table"><table class="table table-sm">
<thead><tr class="header">
<th align="right">pos_hab</th>
<th align="right">lag_poshab</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">14.36500</td>
<td align="right">15.99225</td>
</tr>
<tr class="even">
<td align="right">16.98318</td>
<td align="right">16.81821</td>
</tr>
<tr class="odd">
<td align="right">13.35265</td>
<td align="right">14.48267</td>
</tr>
<tr class="even">
<td align="right">16.16393</td>
<td align="right">12.22961</td>
</tr>
<tr class="odd">
<td align="right">17.36369</td>
<td align="right">12.18342</td>
</tr>
<tr class="even">
<td align="right">17.31354</td>
<td align="right">11.97155</td>
</tr>
</tbody>
</table></div>
<p>El valor de la segunda columna, <code>lag_poshab</code>, es el promedio ponderado de los casos positivos de los vecinos de cada uno de los 76 municipios y alcaldías de nuestra base. Para inspeccionar esto, observemos tanto a los vecinos de una unidad espacial como a sus respectivos valores de <code>pos_hab</code>.</p>
<p>Para identificar a los vecinos de cada observación hay que extraer el dato utilizando dobles corchetes desde el objeto que contiene la estructura espacial no ponderada, <code>mTRUE</code>. Para nuestra observación identificada con el número 1 tenemos:</p>
<div class="sourceCode" id="cb192"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Devuelve el nombre del municipio identificado con el número 1</span>
<span class="va">covid_zmvm</span><span class="op">$</span><span class="va">nom_mun</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></code></pre></div>
<pre><code>## [1] "Ã\201lvaro ObregÃ³n"</code></pre>
<div class="sourceCode" id="cb194"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Devuelve los números de identificación de los municipios y alcaldías vecinas del Álvaro Obregón, la observación identificada con el número 1.</span>
<span class="va">mTRUE</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></code></pre></div>
<pre><code>## [1]  2  7  9 10 11 15</code></pre>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: lower-roman">
<li><p>¿Cómo interpretas el resultado anterior?</p></li>
<li><p>¿Qué son los números que se desplegaron?</p></li>
</ol>
<hr>
<p>Ahora bien, ¿cuál es el valor de los casos positivos por cada 100 mil habitantes para cada una de las observaciones recién obtenidas? Para llamarlas a la consola podemos escribir:</p>
<div class="sourceCode" id="cb196"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Devuelve el nombre de las alcaldías y municipios vecinos de Álvaro Obregón</span>
<span class="va">covid_zmvm</span><span class="op">$</span><span class="va">nom_mun</span><span class="op">[</span><span class="va">mTRUE</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">]</span></code></pre></div>
<pre><code>## [1] "Tlalpan"                "CoyoacÃ¡n"              "Cuajimalpa de Morelos" 
## [4] "Miguel Hidalgo"         "La Magdalena Contreras" "Benito JuÃ¡rez"</code></pre>
<div class="sourceCode" id="cb198"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co">#Devuelve el valor de pos_hab para cada observación vecina de Álvaro Obregón</span>
<span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">[</span><span class="va">mTRUE</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">]</span></code></pre></div>
<pre><code>## [1] 16.98318 14.94352 18.70125 13.67771 20.55956 11.08826</code></pre>
<p>Los valores previamente listados corresponden tanto al nombre como al número de casos positivos de los vecinos de Álvaro Obregón. Así, el primer valor de la tabla es el resultado de (16.98 + 14.94 + 18.70 +13.67 + 20.55 + 11.08)/6, es decir, 15.99.</p>
</div>
<div id="coeficiente-de-correlación-espacial-la-i-de-moran" class="section level3" number="3.3.3">
<h3>
<span class="header-section-number">3.3.3</span> Coeficiente de correlación espacial: la I de Moran<a class="anchor" aria-label="anchor" href="#coeficiente-de-correlaci%C3%B3n-espacial-la-i-de-moran"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Sin duda, el estadístico de asociación espacial más común es la I de Moran, que no es otra cosa que un coeficiente de correlación lineal que “incorpora al espacio”, es decir, mide la asociación lineal entre la variable de interés y su rezago espacial.</p>
<p>Para calcular el coeficiente o estadístico de Moran necesitamos recurrir a la función <code><a href="https://r-spatial.github.io/spdep/reference/moran.test.html">moran.test()</a></code> del paquete <code>spdep</code>. Los argumentos de la función deben especificar el nombre de la variable y el tipo de estructura espacial dado por la matriz de pesos usada; adicionalmente, se puede indicar qué hacer en caso de que existan islas (objetos espaciales sin vecinos) con el argumento <code>zero.policy</code>.</p>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: lower-roman">
<li><p>¿Para qué sirve el argumento <code>randomization</code> de la función <code><a href="https://r-spatial.github.io/spdep/reference/moran.test.html">moran.test()</a></code>?</p></li>
<li><p>¿De qué modo es posible cambiar la hipótesis alternativa de la evaluación de autocorrelación espacial en la prueba de Moran?</p></li>
</ol>
<hr>
<p>Construyamos el estadístico de Moran para la variable <code>pos_hab</code> usando la estructura espacial llamada <code>mTRUE.pesos</code>:</p>
<div class="sourceCode" id="cb200"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/moran.test.html">moran.test</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span>, <span class="va">mTRUE.pesos</span><span class="op">)</span></code></pre></div>
<pre><code>## 
##  Moran I test under randomisation
## 
## data:  covid_zmvm$pos_hab  
## weights: mTRUE.pesos    
## 
## Moran I statistic standard deviate = 8.8625, p-value &lt; 2.2e-16
## alternative hypothesis: greater
## sample estimates:
## Moran I statistic       Expectation          Variance 
##       0.656334129      -0.013333333       0.005709563</code></pre>
<p>Del indicador obtenido nos interesan tres elementos, como es usual: la magnitud del coeficiente, su sentido y su significancia estadística. En los resultados que aparecen en tu consola identifica cada uno de ellos:</p>
<hr>
<p><strong>Ejercicio</strong></p>
<ol style="list-style-type: decimal">
<li><p>¿A cuánto asciende el coeficiente estimado? ¿Podría decirse que es alto o bajo?</p></li>
<li><p>¿La relación identificada es positiva o negativa?</p></li>
</ol>
<hr>
<p>Un coeficiente como el obtenido, de 0.657, indica que hay una relación positiva entre los valores de los casos positivos de COVID19 y los valores de los casos positivos por COVID19 en los entornos vecinos, además, podríamos decir que es relativamente alto en la medida en que el coeficiente puede tomar valores entre -1 y 1 y el que hemos obtenido está más cercano a 1. ¿Qué hay con su significancia estadística? ¿cómo podemos saber que dicho resultado no es producto del azar? Para evaluar su significancia estadística hay que observar el <em>p-value</em>, y evaluemos su significancia estadística a través del siguiente juego de hipótesis:</p>
<ul>
<li>
<span class="math inline">\(Ho:\)</span> distribución espacial aleatoria<br>
</li>
<li>
<span class="math inline">\(Ha:\)</span> distribución espacial no aleatoria</li>
</ul>
<p>Con la información disponible y fijando un nivel de significancia, <span class="math inline">\(\alpha\)</span>, en 0.05 se rechaza la hipótesis nula en favor de la hipótesis alternativa, por tanto, la variable no se distribuye de forma aleatoria en el espacio, sino que muestra indicios de asociación espacial positiva y relativamente alta (0.657).</p>
<hr>
<p><strong>Ejercicio</strong></p>
<p>Construya una I de Moran con la estructura espacial dada por la matriz donde <code>queen=FALSE</code> responda:</p>
<ol style="list-style-type: lower-roman">
<li><p>¿La asociación espacial es positiva o negativa?</p></li>
<li><p>¿Consideras que es alta o baja?</p></li>
<li><p>¿Dirías que dicha relación es producto del azar o que existe un comportamiento sistemático?</p></li>
</ol>
<hr>
</div>
<div id="diagrama-de-dispersión-de-moran" class="section level3" number="3.3.4">
<h3>
<span class="header-section-number">3.3.4</span> Diagrama de dispersión de Moran<a class="anchor" aria-label="anchor" href="#diagrama-de-dispersi%C3%B3n-de-moran"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Una forma creativa de expresar gráficamente la autocorrelación de la variable de interés es a través de un diagrama de dispersión cuyo eje <span class="math inline">\(x\)</span> corresponde a la variable de interés, casos positivos de COVID19 por cada 1 mil habitantes, y en el eje <span class="math inline">\(y\)</span> su rezago espacial; además, al agregar una recta de ajuste sobre los datos estandarizados lograremos que la pendiente de dicha recta corresponda exactamente al valor de la I de Moran. Una de las características del diagrama de Moran es que se descompone en cuatro cuadrantes, tal como aparece en la figura 3.4.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-128"></span>
<img src="recursos%203/Diagrama%20de%20Moran.jpg" alt="Diagrama de dispersión de Moran" width="100%"><p class="caption">
Figura 3.4: Diagrama de dispersión de Moran
</p>
</div>
<p>Para representar el diagrama de dispersión de Moran o simplemente diagrama de Moran recurrimos a la función <code><a href="https://r-spatial.github.io/spdep/reference/moran.plot.html">moran.plot()</a></code> del paquete <code>spdep</code> que para una matriz de tipo reina con el argumento <code>queen=TRUE</code>:</p>
<div class="sourceCode" id="cb202"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/moran.plot.html">moran.plot</a></span><span class="op">(</span><span class="op">(</span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">)</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">)</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/sd.html">sd</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">)</span><span class="op">)</span>,
                  listw <span class="op">=</span> <span class="va">mTRUE.pesos</span>, 
                  xlab<span class="op">=</span><span class="st">"Casos positivos"</span>,
                  ylab<span class="op">=</span><span class="st">"Rezago espacial de los casos positivos"</span>,
                  main<span class="op">=</span><span class="st">"Diagrama de Moran para casos positivos"</span>,
                  col<span class="op">=</span><span class="st">"lightblue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-129-1.png" width="672"></div>
</div>
</div>
<div id="múltiples-elementos-de-personalización-de-ésta-y-otras-gráficas-asociadas-al-paquete-base-de-r-pueden-revisarse-en-la-documentación-de-la-función-par." class="section level2" number="3.4">
<h2>
<span class="header-section-number">3.4</span> Múltiples elementos de personalización de ésta y otras gráficas asociadas al paquete base de R pueden revisarse en la documentación de la función <code>par()</code>.<a class="anchor" aria-label="anchor" href="#m%C3%BAltiples-elementos-de-personalizaci%C3%B3n-de-%C3%A9sta-y-otras-gr%C3%A1ficas-asociadas-al-paquete-base-de-r-pueden-revisarse-en-la-documentaci%C3%B3n-de-la-funci%C3%B3n-par."><i class="fas fa-link"></i></a>
</h2>
<p><strong>Ejercicio</strong></p>
<p>¿Es posible construir un diagrama de Moran usando el paquete ggplot2? De ser así, ¿cómo lo harías de ser así?</p>
<hr>
</div>
<div id="índice-de-moran-local-y-mapa-de-clusters" class="section level2" number="3.5">
<h2>
<span class="header-section-number">3.5</span> Índice de Moran local y mapa de clusters<a class="anchor" aria-label="anchor" href="#%C3%ADndice-de-moran-local-y-mapa-de-clusters"><i class="fas fa-link"></i></a>
</h2>
<div style="text-align: justify">
<p>El índice de Moran que recién hemos descrito permite evaluar la existencia de un patrón espacial completo, por lo que no proporciona información de la ubicación de las agrupaciones, es decir, es una medida de autocorrelación espacial global. Para subsanar esta situación, <span class="citation">(<a href="references.html#ref-Anselin1995" role="doc-biblioref">Anselin 1995</a>)</span> propuso la versión local de la I de Moran: LISA (local indicator of spatial association).</p>
<p>Este indicador:</p>
<ul>
<li>Proporciona un estadístico para cada ubicación con un nivel de significancia.<br>
</li>
<li>Establece una relación proporcional entre el estadístico local y el global.</li>
</ul>
<p>La representación del LISA en un mapa, conocido como <strong>mapa de Cluster</strong> (que permite clasificar las áreas significativas según el tipo de asociación identificada) en compañía con un mapa que indique la significancia estadística de cada valor (muestra las ubicaciones con la I de Moran local que son representativas en diferentes niveles de <span class="math inline">\(\alpha\)</span>) permite la clasificación de las áreas estadísticamente significativas en clusters o agrupamientos (alto-alto y bajo-bajo) y de áreas que se constituyen como observaciones espaciales atípicas o <em>spatial outliers</em> (agrupamientos bajo-alto y alto-bajo).</p>
<p>El Índice local de Moran toma la forma de:</p>
<p><span class="math inline">\(I_i = \frac{(x_i-\bar{x})}{{∑_{k=1}^{n}(x_k-\bar{x})^2}/(n-1)}{∑_{j=1}^{n}w_{ij}(x_j-\bar{x})}\)</span></p>
<p>Para calcular un índice de Moran local en R usamos la función <code><a href="https://r-spatial.github.io/spdep/reference/localmoran.html">localmoran()</a></code>. Creamos un objeto denominado <code>local</code> que echa mano de la matriz <code>mTRUE.pesos</code>:</p>
<div class="sourceCode" id="cb203"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">local</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/localmoran.html">localmoran</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span>, <span class="va">mTRUE.pesos</span><span class="op">)</span></code></pre></div>
<p>El objeto creado, <code>local</code> es de tipo “localmoran”, no es otra cosa que una tabla que contiene múltiples variables cuyo contenido corresponde, según indica la propia ayuda de la función, a:</p>
<ul>
<li>Ii: estadístico de Moran local.<br>
</li>
<li>E.Ii: valor esperado del estadístico de Moran local.<br>
</li>
<li>Var.Ii: varianza del estadístico local de Moran.<br>
</li>
<li>Z.Ii: desviación estándar del estadístico de Moran local.<br>
</li>
<li>Pr (): valor p del estadístico de Moran local.</li>
</ul>
<p>Nos interesa la primera columna, <code>Ii</code>, el índice de Moran local y la columna <code>Pr</code> que contiene la probabilidad asociada, por lo que uniremos los resultados del objeto <code>local</code> a la tabla original que contiene nuestra base de datos. Para eso hay que usar la función <code><a href="https://rdrr.io/r/base/cbind.html">cbind()</a></code> (combinar por columna) en un nuevo objeto que llamaremos <code>mapa.moran</code>:</p>
<div class="sourceCode" id="cb204"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mapa.moran</span> <span class="op">&lt;-</span> <span class="fu">base</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">covid_zmvm</span>, <span class="va">local</span><span class="op">)</span></code></pre></div>
<p>Primero, llevemos los resultados del Moran Local a un mapa de quintiles aplicando las funciones aprendidas en <code>tmap</code>:</p>
<div class="sourceCode" id="cb205"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">tmap</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tmap/man/tm_shape.html">tm_shape</a></span><span class="op">(</span><span class="va">mapa.moran</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">tmap</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tmap/man/tm_polygons.html">tm_fill</a></span><span class="op">(</span>col <span class="op">=</span> <span class="st">"Ii"</span>, style <span class="op">=</span> <span class="st">"quantile"</span>,
                palette <span class="op">=</span> <span class="st">"Spectral"</span>, midpoint<span class="op">=</span> <span class="cn">NA</span>,
                title <span class="op">=</span> <span class="st">"I de Moran local"</span><span class="op">)</span> <span class="op">+</span>
  <span class="fu">tmap</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/tmap/man/tm_polygons.html">tm_borders</a></span><span class="op">(</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-132-1.png" width="672"></div>
<p>El mapa permite observar la manera en que varía la correlación espacial a nivel local. Pero necesitamos otro instrumento que nos permita identificar si los valores de la I de Moran local son o no significativos en esas áreas y de esta manera identificar agrupaciones o núcleos de cluster significativos, así como observaciones espaciales atípicas, es decir, un mapa de significancia. Esto lo hacemos siguiendo la propuesta de <span class="citation">(<a href="references.html#ref-Lovelace2014" role="doc-biblioref">Lovelace y Cheshire 2014</a>)</span>:</p>
<div class="sourceCode" id="cb206"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># crea un vector numérico de la misma longitud del tamaño de filas de la base "local"</span>
<span class="va">cuadrantes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">vector</a></span><span class="op">(</span>mode<span class="op">=</span><span class="st">"numeric"</span>,length<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html">nrow</a></span><span class="op">(</span><span class="va">local</span><span class="op">)</span><span class="op">)</span>

<span class="co"># Centra la variable de interés (CRIME) alrededor de su media</span>
<span class="va">m.COVID</span> <span class="op">&lt;-</span> <span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">covid_zmvm</span><span class="op">$</span><span class="va">pos_hab</span><span class="op">)</span>

<span class="co"># Centra el Índice de Moran local alrededor de su media (columna 1 de la base "local")</span>
<span class="va">m.local</span> <span class="op">&lt;-</span> <span class="va">local</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html">mean</a></span><span class="op">(</span><span class="va">local</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>    

<span class="co"># Fija el umbral de significancia</span>
<span class="va">signif</span> <span class="op">&lt;-</span> <span class="fl">0.05</span> 

<span class="co"># Identificación de los cuadrantes de interés</span>
<span class="va">cuadrantes</span><span class="op">[</span><span class="va">m.COVID</span> <span class="op">&gt;</span><span class="fl">0</span> <span class="op">&amp;</span> <span class="va">m.local</span><span class="op">&gt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">4</span>  
<span class="va">cuadrantes</span><span class="op">[</span><span class="va">m.COVID</span> <span class="op">&lt;</span><span class="fl">0</span> <span class="op">&amp;</span> <span class="va">m.local</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span>      
<span class="va">cuadrantes</span><span class="op">[</span><span class="va">m.COVID</span> <span class="op">&lt;</span><span class="fl">0</span> <span class="op">&amp;</span> <span class="va">m.local</span><span class="op">&gt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span>
<span class="va">cuadrantes</span><span class="op">[</span><span class="va">m.COVID</span> <span class="op">&gt;</span><span class="fl">0</span> <span class="op">&amp;</span> <span class="va">m.local</span><span class="op">&lt;</span><span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">3</span>
<span class="va">cuadrantes</span><span class="op">[</span><span class="va">local</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span><span class="op">&gt;</span><span class="va">signif</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span>   

<span class="co">#Para graficarlo</span>
<span class="va">cortes</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>,<span class="fl">2</span>,<span class="fl">3</span>,<span class="fl">4</span><span class="op">)</span>
<span class="va">colores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"white"</span>,<span class="st">"blue"</span>,<span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1</span>,alpha<span class="op">=</span><span class="fl">0.4</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">0</span>,<span class="fl">0</span>,alpha<span class="op">=</span><span class="fl">0.4</span><span class="op">)</span>,<span class="st">"red"</span><span class="op">)</span>
<span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">mapa.moran</span>, border<span class="op">=</span><span class="st">"lightgray"</span>,col<span class="op">=</span><span class="va">colores</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/findInterval.html">findInterval</a></span><span class="op">(</span><span class="va">cuadrantes</span>,<span class="va">cortes</span>,all.inside<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span><span class="op">]</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/box.html">box</a></span><span class="op">(</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"bottomleft"</span>,legend<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"No signficativo"</span>,<span class="st">"Bajo-Bajo"</span>,<span class="st">"Bajo-alto"</span>,<span class="st">"Alto-Bbajo"</span>,<span class="st">"Alto-Alto"</span><span class="op">)</span>,
       fill<span class="op">=</span><span class="va">colores</span>,bty<span class="op">=</span><span class="st">"n"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-133-1.png" width="672"></div>
<p>El mapa anterior permite identificar agrupamientos de valores significativos al 10%, núcleos de cluster que muestran municipios y alcaldías con valores altos de tasas positivas de COVID19 rodeados de vecinos con valores altos (agrupamiento Alto-Alto), así como agrupamientos de valores bajos (cuadrante Bajo-Bajo), además de observaciones espaciales atípicas (cuadrante Alto-bajo).</p>
<p>En síntesis, hasta este punto hemos visto en este capítulo:</p>
<ol style="list-style-type: lower-roman">
<li>Cómo definir estructuras de relación espacial a través de dos criterios,<br>
</li>
<li>Cómo identificar autocorrelación espacial global a través de la I de Moran,</li>
<li>Cómo evaluar la significancia estadística de la I de Moran,<br>
</li>
<li>Cómo identificar agrupaciones locales a través del indicador LISA.</li>
</ol>
<p>En el capítulo 5 nos adentraremos en cómo incorporar la riqueza que proporciona el análisis espacial en un modelo econométrico. Mientras tanto, en el capítulo 4 llevaremos a cabo un repaso de elementos básicos sobre los modelos de regresión lineal clásica con mínimos cuadrados ordinarios.</p>
</div>
<div id="apéndice-un-enfoque-adicional-para-construir-matrices-de-pesos-espaciales" class="section level2" number="3.6">
<h2>
<span class="header-section-number">3.6</span> Apéndice: Un enfoque adicional para construir matrices de pesos espaciales<a class="anchor" aria-label="anchor" href="#ap%C3%A9ndice-un-enfoque-adicional-para-construir-matrices-de-pesos-espaciales"><i class="fas fa-link"></i></a>
</h2>
<div style="text-align: justify">
<p>Aquí presentamos el enfoque utilizado por el <em>Center for Spatial Data Science</em> de la Universidad de Chicago para la definición de estructuras espaciales. Es una ruta más compleja que la descrita en las secciones previas y, por tanto sino más rica pues permite definir matrices de adyacencia con criterios específicos (torre y reina), así como matrices de umbrales de distancia (k-vecinos más cercanos), tal como se hace en GeoDa. Los paquetes utilizados son:</p>
<ul>
<li>
<code>sf</code>: paquete para el “soporte de funciones simples, una forma estandarizada de codificar datos vectoriales espaciales”, es decir, permite que R lea el tipo de datos que vamos a usar aquí, datos en formato SHP.<br>
</li>
<li>
<code>spdep</code>: el mismo que describimos en el enfoque anterior.</li>
<li>
<code>purrr</code>: es un paquete que potencia las funciones de programación funcional de R, implica cierto conocimiento de cómo automatizar algunas tareas en esta plataforma.<br>
</li>
<li>
<code>ggplot2</code>: el popular paquete para hacer bellas gráficas.<br>
</li>
<li>
<code>knitr</code>: permite generar reportes estilizados en R.</li>
</ul>
<p>Si aún no los has instalado, hazlo. Si ya los instaste, llámalos al entorno de trabajo:</p>
<div class="sourceCode" id="cb207"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/r-spatial/spdep/">spdep</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="http://purrr.tidyverse.org">purrr</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org">ggplot2</a></span><span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://yihui.org/knitr/">knitr</a></span><span class="op">)</span></code></pre></div>
<p>Para construir las matrices de pesos espaciales con este segundo enfoque, es necesario cargar de nueva cuenta la base de datos, pero ahora a través de la función <code><a href="https://r-spatial.github.io/sf/reference/st_read.html">st_read()</a></code> del paquete <code>sf</code>. Para ello, recurrimos a:</p>
<div class="sourceCode" id="cb208"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">covid_zmvm_sf</span> <span class="op">&lt;-</span><span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">st_read</a></span><span class="op">(</span><span class="st">"base de datos\\covid_zmvm shp\\covid_zmvm.shp"</span><span class="op">)</span></code></pre></div>
<pre><code>## Reading layer `covid_zmvm' from data source 
##   `C:\Users\Jarvis\Desktop\Analisis espacial con R studio\base de datos\covid_zmvm shp\covid_zmvm.shp' 
##   using driver `ESRI Shapefile'
## Simple feature collection with 76 features and 55 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: 2745632 ymin: 774927.1 xmax: 2855437 ymax: 899488.5
## Projected CRS: Lambert_Conformal_Conic</code></pre>
<p>Note el tipo de objeto creado (sf) al cargar la base con esta función que difiere del tipo de objeto usado en el primer método (spatial polygon dataframe).</p>
<div id="matriz-tipo-torre-rook" class="section level3" number="3.6.1">
<h3>
<span class="header-section-number">3.6.1</span> Matriz tipo torre (<em>rook</em>)<a class="anchor" aria-label="anchor" href="#matriz-tipo-torre-rook"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>La construcción de las matrices de pesos espaciales en R con este segundo enfoque se hará a través de los paquetes <code>sf</code> y <code>spdep</code>, que permitirá crear una matriz de tipo torre y reina.</p>
<p>Para hacerlo, es necesario seguir dos pasos. En el primero se construirá una función que recoja la relación de vecindad, a esta función la llamaremos <code>func_torre</code> y dentro de dicha función definiremos la relación de vecindad que nos interesa a través de otra función, la función <code><a href="https://r-spatial.github.io/sf/reference/st_relate.html">st_relate()</a></code> del paquete <code>sf</code> que “calcula relaciones entre pares de geometrías o las empareja con un patrón dado. Esta función también tiene un parámetro para un patrón específico” <span class="citation">(<a href="references.html#ref-AnselinMorrison2018" role="doc-biblioref">Anselin y Morrison 2018</a>)</span> y la que nos interesa es el patrón “compartir lados”. Posteriormente, en el segundo paso, aplicamos la función creada a nuestra geometría para crear un objeto de tipo <code>sgbp</code>:</p>
<div class="sourceCode" id="cb210"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">func_torre</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">a</span>, <span class="va">b</span> <span class="op">=</span> <span class="va">a</span><span class="op">)</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_relate.html">st_relate</a></span><span class="op">(</span><span class="va">a</span>, <span class="va">b</span>, pattern <span class="op">=</span> <span class="st">"F***1****"</span><span class="op">)</span><span class="co">#Define la función y sus parámetros</span>
<span class="va">torre.sgbp</span> <span class="op">&lt;-</span> <span class="fu">func_torre</span><span class="op">(</span><span class="va">covid_zmvm_sf</span><span class="op">)</span> <span class="co"># Crea un objeto a partir de la función anterior. Requiere tener cargado el paquete sf</span></code></pre></div>
<p>Observa la estructura y clase que tiene el objeto recién creado, <code>torre.sgbp</code>: es un objeto de tipo <code>sgbp</code>. Para poder interactuar más adelante con este objeto, es necesario modificar su clase. Se trata, pues, de transformar el objeto a una clase <code>nb</code>, es decir, una <em>neighbor list</em> (lista de vecinos). Llevaremos a cabo este procedimiento creando una función para el caso, <code>as.nb.sgbp</code>. Esta función nos permitirá además lidiar con los polígonos que no tienen vecinos.</p>
<div class="sourceCode" id="cb211"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">as.nb.sgbp</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span><span class="op">)</span> <span class="op">{</span><span class="co">#Define la función con 1 argumento, un objeto de tipo `sgbp`</span>
  <span class="va">attrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/attributes.html">attributes</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="co">#Guarda los atributos del objeto de tipo sgbp</span>
  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">x</span>, <span class="kw">function</span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">{</span> <span class="kw">if</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">i</span><span class="op">)</span> <span class="op">==</span> <span class="fl">0L</span><span class="op">)</span> <span class="fl">0L</span> <span class="kw">else</span> <span class="va">i</span> <span class="op">}</span> <span class="op">)</span> <span class="co">#Función que coloca un 0 a cada elemento sin vecinos.</span>
  <span class="fu"><a href="https://rdrr.io/r/base/attributes.html">attributes</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">attrs</span> <span class="co">#aplica los atributos recién modificados al argumento x.</span>
  <span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="st">"nb"</span> <span class="co"># Cambia el tipo de objeto de `sgbp` a `nb`</span>
  <span class="va">x</span> <span class="co">#Devuelve el objeto</span>
<span class="op">}</span></code></pre></div>
<p>Ahora, a través de la función recién creada trasformaremos el objeto <code>torre.sgbp</code> a un objeto de clase <code>nb</code>.</p>
<div class="sourceCode" id="cb212"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">torre.nb</span> <span class="op">&lt;-</span> <span class="fu">as.nb.sgbp</span><span class="op">(</span><span class="va">torre.sgbp</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">torre.nb</span><span class="op">)</span></code></pre></div>
<pre><code>## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 196 
## Percentage nonzero weights: 3.393352 
## Average number of links: 2.578947 
## 18 regions with no links:
## 4 5 6 9 10 11 14 15 16 30 34 37 48 53 64 67 73 76
## Link number distribution:
## 
##  0  1  2  3  4  5  6  7  8 
## 18 13  8 11 12  7  1  3  3 
## 13 least connected regions:
## 1 2 3 7 13 19 23 32 35 38 49 51 75 with 1 link
## 3 most connected regions:
## 28 46 71 with 8 links</code></pre>
<div class="sourceCode" id="cb214"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">torre.nb</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] "nb"</code></pre>
<div class="sourceCode" id="cb216"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">torre.nb</span><span class="op">)</span></code></pre></div>
<pre><code>## [1] 76</code></pre>
<p>Finalmente, construimos la matriz (lista) ponderada a través de la función <code><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw()</a></code>, verifique por su cuenta la estructura del objeto creado:</p>
<div class="sourceCode" id="cb218"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">torre.pesos</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw</a></span><span class="op">(</span><span class="va">torre.nb</span>, zero.policy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
</div>
<div id="matriz-tipo-reyna-queen" class="section level3" number="3.6.2">
<h3>
<span class="header-section-number">3.6.2</span> Matriz tipo reyna (<em>queen</em>)<a class="anchor" aria-label="anchor" href="#matriz-tipo-reyna-queen"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Procedemos de forma semejante para la construcción de una matriz tipo torre, a través de un par de funciones. Primero, se establece la función que recoge los patrones de interés, “compartir lados y vértices”:</p>
<div class="sourceCode" id="cb219"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">func_reina</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">a</span>, <span class="va">b</span> <span class="op">=</span> <span class="va">a</span><span class="op">)</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_relate.html">st_relate</a></span><span class="op">(</span><span class="va">a</span>, <span class="va">b</span>, pattern <span class="op">=</span> <span class="st">"F***T****"</span><span class="op">)</span></code></pre></div>
<p>Luego, con esta función, creamos un objeto de tipo <code>sgbp</code> que contendrá los elementos informativos de vecindad tipo reina:</p>
<div class="sourceCode" id="cb220"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.sgbp</span> <span class="op">&lt;-</span> <span class="fu">func_reina</span><span class="op">(</span><span class="va">covid_zmvm_sf</span><span class="op">)</span></code></pre></div>
<p>A continuación convertimos el objeto creado de <code>sgbp</code> a <code>nb</code> con la función elaborada en la secuencia de la matriz tipo torre:</p>
<div class="sourceCode" id="cb221"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.nb</span> <span class="op">&lt;-</span> <span class="fu">as.nb.sgbp</span><span class="op">(</span><span class="va">reina.sgbp</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">reina.nb</span><span class="op">)</span></code></pre></div>
<pre><code>## Neighbour list object:
## Number of regions: 76 
## Number of nonzero links: 206 
## Percentage nonzero weights: 3.566482 
## Average number of links: 2.710526 
## 18 regions with no links:
## 4 5 6 9 10 11 14 15 16 30 34 37 48 53 64 67 73 76
## Link number distribution:
## 
##  0  1  2  3  4  5  6  7  8 
## 18 13  7 12  7  9  3  4  3 
## 13 least connected regions:
## 1 2 3 7 13 19 23 32 35 38 49 51 75 with 1 link
## 3 most connected regions:
## 28 46 71 with 8 links</code></pre>
<p>Es turno de la matriz ponderada:</p>
<div class="sourceCode" id="cb223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.pesos</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw</a></span><span class="op">(</span><span class="va">reina.nb</span>, zero.policy <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
</div>
<div id="matrices-de-contigüidad-de-orden-superior" class="section level3" number="3.6.3">
<h3>
<span class="header-section-number">3.6.3</span> Matrices de contigüidad de orden superior<a class="anchor" aria-label="anchor" href="#matrices-de-contig%C3%BCidad-de-orden-superior"><i class="fas fa-link"></i></a>
</h3>
<div style="text-align: justify">
<p>Es posible contar con matrices de órdenes superiores, para ello, recurrimos a la función <code><a href="https://r-spatial.github.io/spdep/reference/nblag.html">nblag()</a></code> con la que creamos un objeto del que, en el segundo paso, extraeremos la información de interés. Nota que el orden de contigüidad está establecido en el segundo argumento:</p>
<div class="sourceCode" id="cb224"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.2o</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nblag.html">nblag</a></span><span class="op">(</span><span class="va">reina.nb</span>, <span class="fl">2</span><span class="op">)</span></code></pre></div>
<p>Verifica la estructura con <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>. A partir del objeto realizado, <code>reina.2o</code>, se creará otro de tipo <code>nb</code> que contendrá la información relativa a los datos de vecindad de tipo reina de orden 2, a través de una selección del segundo elemento de dicho objeto:</p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.2o.nb</span> <span class="op">&lt;-</span> <span class="va">reina.2o</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></code></pre></div>
<p>Para poder tener los dos tipos de estructura espacial (reina de primer y de segundo orden) en un solo objeto, es necesario crear un objeto a partir de la función <code><a href="https://r-spatial.github.io/spdep/reference/nblag.html">nblag_cumul()</a></code> que arrojará como resultado un elemento de tipo <code>nb</code> que contendrá tanto la estructura de dependencia de primer como la de segundo orden:</p>
<div class="sourceCode" id="cb226"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">reina.ambos</span> <span class="op">&lt;-</span> <span class="fu">spdep</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nblag.html">nblag_cumul</a></span><span class="op">(</span><span class="va">reina.2o</span><span class="op">)</span></code></pre></div>
</div>
</div>
<div id="visualización-de-la-estructura-espacial" class="section level2" number="3.7">
<h2>
<span class="header-section-number">3.7</span> Visualización de la estructura espacial<a class="anchor" aria-label="anchor" href="#visualizaci%C3%B3n-de-la-estructura-espacial"><i class="fas fa-link"></i></a>
</h2>
<div style="text-align: justify">
<p>La visualización de la estructura espacial en este segundo enfoque es un poco más complicada, pues para poder mostrarla en un mapa de conectividad es necesario contar con los centroides geométricos como objetos independientes, es decir, como un par de coordenadas en un objeto independiente. Éstos los extraeremos del atributo “Geometry” que aparece en nuestra base de datos de tipo <code>sf</code> (<code>covid_zmvm_sf</code>). Para extraerlos usaremos la función <code><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl()</a></code> del paquete <code>purrr</code> y <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code> del paquete <code>sf</code>, como se muestra enseguida:</p>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">longitud</span> <span class="op">&lt;-</span> <span class="fu">purrr</span><span class="fu">::</span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span><span class="op">(</span><span class="va">covid_zmvm_sf</span><span class="op">$</span><span class="va">geometry</span>, <span class="op">~</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">.x</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span>
<span class="va">latitud</span> <span class="op">&lt;-</span> <span class="fu">purrr</span><span class="fu">::</span><span class="fu"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span><span class="op">(</span><span class="va">covid_zmvm_sf</span><span class="op">$</span><span class="va">geometry</span>, <span class="op">~</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">.x</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></code></pre></div>
<p>Ahora, esos elementos los guardamos en un nuevo objeto con la función “combina por columna”, es decir, <code><a href="https://rdrr.io/r/base/cbind.html">cbind()</a></code> (<em>column bind</em>):</p>
<div class="sourceCode" id="cb228"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">coords</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">longitud</span>, <span class="va">latitud</span><span class="op">)</span></code></pre></div>
<p>Para poder visualizar la estructura espacial de cada tipo de vecindad debemos graficar los centroides, la geometría de interés y las líneas que unen los centroides ,las cuales indican la vecindad. Para el caso de la matriz tipo torre:</p>
<div class="sourceCode" id="cb229"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">torre.nb</span>, <span class="va">coords</span>, lwd<span class="op">=</span><span class="fl">.2</span>, col<span class="op">=</span><span class="st">"blue"</span>, cex <span class="op">=</span> <span class="fl">.5</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-149-1.png" width="672"></div>
<p>Para el caso de la matriz de tipo reina de primer orden:</p>
<div class="sourceCode" id="cb230"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">reina.nb</span>, <span class="va">coords</span>, lwd<span class="op">=</span><span class="fl">.2</span>, col<span class="op">=</span><span class="st">"red"</span>, cex <span class="op">=</span> <span class="fl">.5</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-150-1.png" width="672"></div>
<p>Para la de segundo orden:</p>
<div class="sourceCode" id="cb231"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">reina.2o.nb</span>, <span class="va">coords</span>, lwd<span class="op">=</span><span class="fl">.2</span>, col<span class="op">=</span><span class="st">"blue"</span>, cex <span class="op">=</span> <span class="fl">.5</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-151-1.png" width="672"></div>
</div>
<div id="matrices-de-distancia-k-vecinos-más-cercanos" class="section level2" number="3.8">
<h2>
<span class="header-section-number">3.8</span> Matrices de distancia: k-vecinos más cercanos<a class="anchor" aria-label="anchor" href="#matrices-de-distancia-k-vecinos-m%C3%A1s-cercanos"><i class="fas fa-link"></i></a>
</h2>
<div style="text-align: justify">
<p>En este segundo enfoque expuesto, el de Anselin y su equipo, es posible construir otro tipo de matrices a partir de umbrales de distancia: matriz de k-vecinos más cercanos. Para ello, usaremos de nueva cuenta las coordenadas con los centroides como punto de referencia para medir la distancia (el objeto <code>coords</code>). Luego, a través de dos funciones <code>knearneigh</code> y <code>knn2nb</code> del paquete <code>spdep</code> construiremos la matriz, transformándola enseguida en un objeto de tipo <code>nb</code>. Luego, la convertiremos propiamente en un objeto tipo lista con los pesos:</p>
<div class="sourceCode" id="cb232"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">k6nb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-spatial.github.io/spdep/reference/knn2nb.html">knn2nb</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/spdep/reference/knearneigh.html">knearneigh</a></span><span class="op">(</span><span class="va">coords</span>, k <span class="op">=</span> <span class="fl">6</span><span class="op">)</span><span class="op">)</span>
<span class="va">k6.pesos</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://r-spatial.github.io/spdep/reference/nb2listw.html">nb2listw</a></span><span class="op">(</span><span class="va">k6nb</span><span class="op">)</span></code></pre></div>
<p>Para visualizar la estructura espacial:</p>
<div class="sourceCode" id="cb233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://r-spatial.github.io/sf/reference/plot.html">plot</a></span><span class="op">(</span><span class="va">k6nb</span>, <span class="va">coords</span>, lwd<span class="op">=</span><span class="fl">.2</span>, col<span class="op">=</span><span class="st">"blue"</span>, cex <span class="op">=</span> <span class="fl">.5</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="_main_files/figure-html/unnamed-chunk-153-1.png" width="672"></div>

</div>
</div>

  

  

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Análisis de datos espaciales con R: manejo, visualización y modelos econométricos</strong>" was written by Jaime Alberto Prudencio Vázquez. It was last built on 2022-01-19.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="chapter-nav">
<div class="prev"><a href="mapas-coropl%C3%A9ticos-en-r.html"><span class="header-section-number">2</span> Mapas coropléticos en R</a></div>
<div class="next"><a href="modelos-de-regresi%C3%B3n-lineal.html"><span class="header-section-number">4</span> Modelos de regresión lineal</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#an%C3%A1lisis-espacial-i-autocorrelaci%C3%B3n"><span class="header-section-number">3</span> Análisis espacial I: autocorrelación</a></li>
<li><a class="nav-link" href="#autocorrelaci%C3%B3n-y-dependencia-espacial"><span class="header-section-number">3.1</span> Autocorrelación y dependencia espacial</a></li>
<li>
<a class="nav-link" href="#matrices-de-pesos-espaciales-en-r"><span class="header-section-number">3.2</span> Matrices de pesos espaciales en R</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#los-paquetes-1"><span class="header-section-number">3.2.1</span> Los paquetes</a></li>
<li><a class="nav-link" href="#matrices-de-contig%C3%BCidad-el-argumento-queen-de-la-funci%C3%B3n-poly2nb"><span class="header-section-number">3.2.2</span> Matrices de contigüidad: el argumento queen de la función poly2nb()</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#estad%C3%ADsticos-de-correlaci%C3%B3n-espacial"><span class="header-section-number">3.3</span> Estadísticos de correlación espacial</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#la-matriz-de-pesos-espaciales-estandarizada"><span class="header-section-number">3.3.1</span> La matriz de pesos espaciales estandarizada</a></li>
<li><a class="nav-link" href="#el-rezago-o-retardo-espacial"><span class="header-section-number">3.3.2</span> El rezago o retardo espacial</a></li>
<li><a class="nav-link" href="#coeficiente-de-correlaci%C3%B3n-espacial-la-i-de-moran"><span class="header-section-number">3.3.3</span> Coeficiente de correlación espacial: la I de Moran</a></li>
<li><a class="nav-link" href="#diagrama-de-dispersi%C3%B3n-de-moran"><span class="header-section-number">3.3.4</span> Diagrama de dispersión de Moran</a></li>
</ul>
</li>
<li><a class="nav-link" href="#m%C3%BAltiples-elementos-de-personalizaci%C3%B3n-de-%C3%A9sta-y-otras-gr%C3%A1ficas-asociadas-al-paquete-base-de-r-pueden-revisarse-en-la-documentaci%C3%B3n-de-la-funci%C3%B3n-par."><span class="header-section-number">3.4</span> Múltiples elementos de personalización de ésta y otras gráficas asociadas al paquete base de R pueden revisarse en la documentación de la función par().</a></li>
<li><a class="nav-link" href="#%C3%ADndice-de-moran-local-y-mapa-de-clusters"><span class="header-section-number">3.5</span> Índice de Moran local y mapa de clusters</a></li>
<li>
<a class="nav-link" href="#ap%C3%A9ndice-un-enfoque-adicional-para-construir-matrices-de-pesos-espaciales"><span class="header-section-number">3.6</span> Apéndice: Un enfoque adicional para construir matrices de pesos espaciales</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#matriz-tipo-torre-rook"><span class="header-section-number">3.6.1</span> Matriz tipo torre (rook)</a></li>
<li><a class="nav-link" href="#matriz-tipo-reyna-queen"><span class="header-section-number">3.6.2</span> Matriz tipo reyna (queen)</a></li>
<li><a class="nav-link" href="#matrices-de-contig%C3%BCidad-de-orden-superior"><span class="header-section-number">3.6.3</span> Matrices de contigüidad de orden superior</a></li>
</ul>
</li>
<li><a class="nav-link" href="#visualizaci%C3%B3n-de-la-estructura-espacial"><span class="header-section-number">3.7</span> Visualización de la estructura espacial</a></li>
<li><a class="nav-link" href="#matrices-de-distancia-k-vecinos-m%C3%A1s-cercanos"><span class="header-section-number">3.8</span> Matrices de distancia: k-vecinos más cercanos</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>
</div>
</div>
</body>
</html>
